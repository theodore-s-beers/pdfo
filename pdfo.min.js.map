{
  "version": 3,
  "sources": ["pdfo.ts"],
  "sourcesContent": ["// This library was forked from Philip Hutchison's PDFObject. His license is\n// below. A substantial, and growing, number of changes has been made---not\n// least the conversion to TypeScript.\n\n/*!\n *  PDFObject v2.2.7\n *  https://github.com/pipwerks/PDFObject\n *  @license\n *  Copyright (c) 2008\u20132021 Philip Hutchison\n *  MIT-style license: https://pipwerks.mit-license.org/\n */\n\n//\n// TYPES\n//\n\ninterface EmbedOptions {\n  assumeSupport?: boolean;\n  fallbackLink?: string;\n  fallbackPrefix?: string;\n  height?: string;\n  omitInlineStyles?: boolean;\n  pdfOpenParams?: Record<string, unknown>;\n  width?: string;\n}\n\n//\n// GLOBAL VARIABLES\n//\n\n// Shorthand variables for Navigator object and UA string\nconst nav = window.navigator;\nconst ua = nav.userAgent;\n\n// A recent, and still Chromium-only, way of checking for a mobile browser\nconst newMobileTest = nav.userAgentData?.mobile;\n\n// Safari on iPadOS doesn't report as \"mobile\" when requesting a desktop site,\n// yet still fails to embed PDFs.\nconst isSafariIPadOS = /Macintosh/i.test(ua) && nav.maxTouchPoints > 1;\n\n// Our best guess as to whether we're dealing with a mobile device\nconst isMobileDevice =\n  newMobileTest === true ||\n  /Mobi|Tablet|Android|iPad|iPhone/.test(ua) ||\n  isSafariIPadOS;\n\n//\n// PUBLIC FUNCTIONS\n//\n\nexport function embed(\n  url: string,\n  targetSelector?: string,\n  options?: EmbedOptions,\n): void {\n  // Ensure options not undefined -- enables easier error checking below\n  const opt = options || {};\n\n  // Get passed options, or set reasonable defaults\n  const pdfOpenParams = opt.pdfOpenParams || {};\n  const width = opt.width || \"100%\";\n  const height = opt.height || \"100%\";\n  const assumeSupport = opt.assumeSupport !== false; // true unless explicitly false\n  const omitInlineStyles = opt.omitInlineStyles === true; // false unless explicitly true\n\n  // Fallback options require special handling\n  const fallbackLink =\n    typeof opt.fallbackLink === \"string\"\n      ? opt.fallbackLink\n      : \"<p>This browser does not support embedded PDFs. Please download the file to view it: <a href='[url]'>Download PDF</a></p>\";\n  const fallbackPrefix = opt.fallbackPrefix || \"\";\n\n  const selector = targetSelector || \"\";\n  const targetNode = getTargetElement(selector);\n\n  // If target element is specified but not valid, exit without doing anything\n  // How would targetNode be falsy? I don't yet understand this\n  if (!targetNode) {\n    return embedError(\"Target element cannot be determined\");\n  }\n\n  // Stringify optional Adobe params for opening PDF (as fragment identifier)\n  const pdfOpenFragment = buildURLFragmentString(pdfOpenParams);\n\n  // --== Attempt embed ==--\n\n  // Embed PDF if traditional support is provided, or if this developer is\n  // willing to roll with assumption that modern desktop (not mobile) browsers\n  // natively support PDFs\n  if (supportsPDFs() || (assumeSupport && !isMobileDevice)) {\n    // Historically, the PDFObject library used <embed> elements by default,\n    // while providing the option of using <iframe> instead. Over time, it\n    // became increasingly common for browsers to have trouble with <embed>. I\n    // think we are on a trajectory to where <embed> will be effectively a\n    // deprecated element. <iframe> can do everything that <embed> can do, and\n    // it sees much, much more use. My choice for the pdfo fork of PDFObject,\n    // until further notice, is to use only <iframe>. This allows for some\n    // simplification of both the API and library logic. If there are indeed\n    // users who prefer <embed>, the change can be reversed.\n    const embedType = \"iframe\";\n\n    return generatePDFoMarkup(\n      embedType,\n      targetNode,\n      url,\n      pdfOpenFragment,\n      width,\n      height,\n      omitInlineStyles,\n    );\n  }\n\n  // --== PDF embed not supported! Use fallback ==--\n\n  if (fallbackPrefix) {\n    const embedType = \"fallback\";\n\n    return generatePDFoMarkup(\n      embedType,\n      targetNode,\n      fallbackPrefix + url,\n      pdfOpenFragment,\n      width,\n      height,\n      omitInlineStyles,\n    );\n  }\n\n  // Last resort: display fallback link (if available) and return an error\n  if (fallbackLink) {\n    targetNode.innerHTML = fallbackLink.replace(/\\[url\\]/, url);\n  }\n\n  return embedError(\"This browser does not support embedded PDFs\");\n}\n\nexport function supportsPDFs(): boolean {\n  // For now it seems safest to return false for any mobile device, since they\n  // sometimes claim to support PDFs but don't do so properly.\n  if (isMobileDevice) {\n    return false;\n  }\n\n  // This property is supposed to provide a simple answer to the question of\n  // whether inline PDFs are supported. Unfortunately, I have found that Safari\n  // on iOS returns true, but the PDF embedding is janky (it displays only the\n  // first page). So we'll return this value if it's available, but only after\n  // ruling out mobile devices.\n  if (typeof nav.pdfViewerEnabled === \"boolean\") {\n    return nav.pdfViewerEnabled;\n  }\n\n  // At this point, we would be dealing with a non-mobile browser that doesn't\n  // support the pdfViewerEnabled property. The best that we can do is to check\n  // that the browser is relatively modern, and if so, to return true.\n\n  // There is a coincidental correlation between implementation of promises and\n  // native PDF support in desktop browsers.\n  const isModernBrowser = typeof Promise !== \"undefined\";\n\n  return isModernBrowser;\n}\n\n//\n// PRIVATE FUNCTIONS (alphabetical)\n//\n\nfunction buildURLFragmentString(pdfParams: Record<string, unknown>): string {\n  let str = \"\";\n\n  if (pdfParams) {\n    for (const prop in pdfParams) {\n      if (Object.prototype.hasOwnProperty.call(pdfParams, prop)) {\n        str += `${encodeURIComponent(prop)}=${encodeURIComponent(\n          String(pdfParams[prop]),\n        )}&`;\n      }\n    }\n\n    // String will be empty if no PDF Params found\n    if (str) {\n      str = `#${str}`;\n\n      // Remove final ampersand\n      str = str.slice(0, str.length - 1);\n    }\n  }\n\n  return str;\n}\n\nfunction embedError(msg: string): void {\n  console.log(`[pdfo] ${msg}`);\n}\n\nfunction emptyNodeContents(node: HTMLElement): void {\n  while (node.firstChild) {\n    node.removeChild(node.firstChild);\n  }\n}\n\nfunction generatePDFoMarkup(\n  embedType: string,\n  targetNode: HTMLElement,\n  url: string,\n  pdfOpenFragment: string,\n  width: string,\n  height: string,\n  omitInlineStyles: boolean,\n): void {\n  // Ensure target element is empty\n  emptyNodeContents(targetNode);\n\n  const embed = document.createElement(\"iframe\");\n  embed.allow = \"fullscreen\";\n\n  embed.src = embedType === \"fallback\" ? url : url + pdfOpenFragment;\n  embed.className = \"pdfo\";\n\n  if (!omitInlineStyles) {\n    let styles = \"border: none;\";\n\n    if (targetNode === document.body) {\n      styles +=\n        \"position: absolute; top: 0; right: 0; bottom: 0; left: 0; width: 100%; height: 100%;\";\n    } else {\n      styles += `width: ${width}; height: ${height};`;\n    }\n\n    embed.style.cssText = styles;\n  }\n\n  targetNode.classList.add(\"pdfo-container\");\n\n  // This is where the magic finally happens\n  targetNode.appendChild(embed);\n}\n\nfunction getTargetElement(targetSelector: string): HTMLElement {\n  let targetNode: HTMLElement;\n\n  if (targetSelector) {\n    targetNode = document.querySelector(targetSelector) || document.body;\n  } else {\n    targetNode = document.body;\n  }\n\n  return targetNode;\n}\n"],
  "mappings": "aA+BA,MAAMA,EAAM,OAAO,UACbC,EAAKD,EAAI,UAGTE,EAAgBF,EAAI,eAAe,OAInCG,EAAiB,aAAa,KAAKF,CAAE,GAAKD,EAAI,eAAiB,EAG/DI,EACJF,IAAkB,IAClB,kCAAkC,KAAKD,CAAE,GACzCE,EAMK,gBAAS,MACdE,EACAC,EACAC,EACM,CAEN,MAAMC,EAAMD,GAAW,CAAC,EAGlBE,EAAgBD,EAAI,eAAiB,CAAC,EACtCE,EAAQF,EAAI,OAAS,OACrBG,EAASH,EAAI,QAAU,OACvBI,EAAgBJ,EAAI,gBAAkB,GACtCK,EAAmBL,EAAI,mBAAqB,GAG5CM,EACJ,OAAON,EAAI,cAAiB,SACxBA,EAAI,aACJ,4HACAO,EAAiBP,EAAI,gBAAkB,GAGvCQ,EAAaC,EADFX,GAAkB,EACS,EAI5C,GAAI,CAACU,EACH,OAAOE,EAAW,qCAAqC,EAIzD,MAAMC,EAAkBC,EAAuBX,CAAa,EAO5D,OAAI,aAAa,GAAMG,GAAiB,CAACR,EAYhCiB,EAFW,SAIhBL,EACAX,EACAc,EACAT,EACAC,EACAE,CACF,EAKEE,EAGKM,EAFW,WAIhBL,EACAD,EAAiBV,EACjBc,EACAT,EACAC,EACAE,CACF,GAIEC,IACFE,EAAW,UAAYF,EAAa,QAAQ,UAAWT,CAAG,GAGrDa,EAAW,6CAA6C,EACjE,CAEO,gBAAS,cAAwB,CAGtC,OAAId,EACK,GAQL,OAAOJ,EAAI,kBAAqB,UAC3BA,EAAI,iBASW,OAAO,QAAY,GAG7C,CAMA,SAASoB,EAAuBE,EAA4C,CAC1E,IAAIC,EAAM,GAEV,GAAID,EAAW,CACb,UAAWE,KAAQF,EACb,OAAO,UAAU,eAAe,KAAKA,EAAWE,CAAI,IACtDD,GAAO,GAAG,mBAAmBC,CAAI,CAAC,IAAI,mBACpC,OAAOF,EAAUE,CAAI,CAAC,CACxB,CAAC,KAKDD,IACFA,EAAM,IAAIA,CAAG,GAGbA,EAAMA,EAAI,MAAM,EAAGA,EAAI,OAAS,CAAC,EAErC,CAEA,OAAOA,CACT,CAEA,SAASL,EAAWO,EAAmB,CACrC,QAAQ,IAAI,UAAUA,CAAG,EAAE,CAC7B,CAEA,SAASC,EAAkBC,EAAyB,CAClD,KAAOA,EAAK,YACVA,EAAK,YAAYA,EAAK,UAAU,CAEpC,CAEA,SAASN,EACPO,EACAZ,EACAX,EACAc,EACAT,EACAC,EACAE,EACM,CAENa,EAAkBV,CAAU,EAE5B,MAAMa,EAAQ,SAAS,cAAc,QAAQ,EAM7C,GALAA,EAAM,MAAQ,aAEdA,EAAM,IAAMD,IAAc,WAAavB,EAAMA,EAAMc,EACnDU,EAAM,UAAY,OAEd,CAAChB,EAAkB,CACrB,IAAIiB,EAAS,gBAETd,IAAe,SAAS,KAC1Bc,GACE,uFAEFA,GAAU,UAAUpB,CAAK,aAAaC,CAAM,IAG9CkB,EAAM,MAAM,QAAUC,CACxB,CAEAd,EAAW,UAAU,IAAI,gBAAgB,EAGzCA,EAAW,YAAYa,CAAK,CAC9B,CAEA,SAASZ,EAAiBX,EAAqC,CAC7D,IAAIU,EAEJ,OAAIV,EACFU,EAAa,SAAS,cAAcV,CAAc,GAAK,SAAS,KAEhEU,EAAa,SAAS,KAGjBA,CACT",
  "names": ["nav", "ua", "newMobileTest", "isSafariIPadOS", "isMobileDevice", "url", "targetSelector", "options", "opt", "pdfOpenParams", "width", "height", "assumeSupport", "omitInlineStyles", "fallbackLink", "fallbackPrefix", "targetNode", "getTargetElement", "embedError", "pdfOpenFragment", "buildURLFragmentString", "generatePDFoMarkup", "pdfParams", "str", "prop", "msg", "emptyNodeContents", "node", "embedType", "embed", "styles"]
}
