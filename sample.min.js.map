{
  "version": 3,
  "sources": ["pdfo.ts", "sample.ts"],
  "sourcesContent": ["// This library was forked from Philip Hutchison's PDFObject. His license is\n// below. A substantial, and growing, number of changes has been made---not\n// least the conversion to TypeScript.\n\n/*!\n *  PDFObject v2.2.7\n *  https://github.com/pipwerks/PDFObject\n *  @license\n *  Copyright (c) 2008\u20132021 Philip Hutchison\n *  MIT-style license: https://pipwerks.mit-license.org/\n */\n\n//\n// TYPES\n//\n\ninterface EmbedOptions {\n  assumeSupport?: boolean\n  fallbackLink?: string\n  fallbackPrefix?: string\n  height?: string\n  omitInlineStyles?: boolean\n  pdfOpenParams?: Record<string, unknown>\n  width?: string\n}\n\n//\n// GLOBAL VARIABLES\n//\n\n// Shorthand variables for Navigator object and UA string\nconst nav = window.navigator\nconst ua = window.navigator.userAgent\n\n// A recent, and still Chromium-only, way of checking for a mobile browser\nconst newMobileTest = nav.userAgentData?.mobile\n\n// Safari on iPadOS doesn't report as \"mobile\" when requesting a desktop site,\n// yet still fails to embed PDFs.\nconst isSafariIOSDesktopMode =\n  nav.platform !== undefined &&\n  nav.platform === 'MacIntel' &&\n  nav.maxTouchPoints !== undefined &&\n  nav.maxTouchPoints > 1\n\n// Our best guess as to whether we're dealing with a mobile device\nconst isMobileDevice =\n  newMobileTest === true ||\n  /Mobi|Tablet|Android|iPad|iPhone/.test(ua) ||\n  isSafariIOSDesktopMode\n\n//\n// PUBLIC FUNCTIONS\n//\n\nexport function embed (\n  url: string,\n  targetSelector?: string,\n  options?: EmbedOptions\n): void {\n  // Ensure options not undefined -- enables easier error checking below\n  const opt = options || {}\n\n  // Get passed options, or set reasonable defaults\n  const pdfOpenParams = opt.pdfOpenParams || {}\n  const width = opt.width || '100%'\n  const height = opt.height || '100%'\n  const assumeSupport =\n    typeof opt.assumeSupport === 'boolean' ? opt.assumeSupport : true\n  const omitInlineStyles =\n    typeof opt.omitInlineStyles === 'boolean' ? opt.omitInlineStyles : false\n\n  // Fallback options require special handling\n  const fallbackLink =\n    typeof opt.fallbackLink === 'string'\n      ? opt.fallbackLink\n      : \"<p>This browser does not support inline PDFs. Please download the file to view it: <a href='[url]'>Download PDF</a></p>\"\n  const fallbackPrefix = opt.fallbackPrefix || ''\n\n  const selector = targetSelector || ''\n  const targetNode = getTargetElement(selector)\n\n  // If target element is specified but not valid, exit without doing anything\n  // How would targetNode be falsy? I don't yet understand this\n  if (!targetNode) {\n    return embedError('Target element cannot be determined')\n  }\n\n  // Stringify optional Adobe params for opening PDF (as fragment identifier)\n  const pdfOpenFragment = buildURLFragmentString(pdfOpenParams)\n\n  // --== Attempt embed ==--\n\n  // Embed PDF if traditional support is provided, or if this developer is\n  // willing to roll with assumption that modern desktop (not mobile) browsers\n  // natively support PDFs\n  if (supportsPDFs() || (assumeSupport && !isMobileDevice)) {\n    // Historically, the PDFObject library used <embed> elements by default,\n    // while providing the option of using <iframe> instead. Over time, it\n    // became increasingly common for browsers to have trouble with <embed>. I\n    // think we are on a trajectory to where <embed> will be effectively a\n    // deprecated element. <iframe> can do everything that <embed> can do, and\n    // it sees much, much more use. My choice for the pdfo fork of PDFObject,\n    // until further notice, is to use only <iframe>. This allows for some\n    // simplification of both the API and library logic. If there are indeed\n    // users who prefer <embed>, the change can be reversed.\n    const embedType = 'iframe'\n\n    return generatePDFoMarkup(\n      embedType,\n      targetNode,\n      url,\n      pdfOpenFragment,\n      width,\n      height,\n      omitInlineStyles\n    )\n  }\n\n  // --== PDF embed not supported! Use fallback ==--\n\n  if (fallbackPrefix) {\n    const embedType = 'fallback'\n\n    return generatePDFoMarkup(\n      embedType,\n      targetNode,\n      fallbackPrefix + url,\n      pdfOpenFragment,\n      width,\n      height,\n      omitInlineStyles\n    )\n  }\n\n  // Last resort: display fallback link (if available) and return an error\n  if (fallbackLink) {\n    targetNode.innerHTML = fallbackLink.replace(/\\[url\\]/, url)\n  }\n\n  return embedError('This browser does not support embedded PDFs')\n}\n\nexport function supportsPDFs (): boolean {\n  // New property available in recent versions of Chrome and Firefox\n  const pdfViewerEnabled = nav.pdfViewerEnabled\n\n  // If this comes back true or false, best to just go with it?\n  if (typeof pdfViewerEnabled === 'boolean') {\n    return pdfViewerEnabled\n  }\n\n  /*\n    There is a coincidental correlation between implementation of promises and \n    native PDF support in desktop browsers.\n    We assume that if the browser supports promises it supports embedded PDFs.\n    Is this fragile? Sort of. But browser vendors removed mimetype detection, \n    so we're left to improvise\n  */\n  const isModernBrowser = typeof Promise !== 'undefined'\n\n  // We're moving into the age of MIME-less browsers.\n  // They mostly all support PDF rendering without plugins.\n  const likelySupportsPDFs = !isMobileDevice && isModernBrowser\n\n  return likelySupportsPDFs\n}\n\n//\n// PRIVATE FUNCTIONS (alphabetical)\n//\n\nfunction buildURLFragmentString (pdfParams: Record<string, unknown>): string {\n  let string = ''\n\n  if (pdfParams) {\n    for (const prop in pdfParams) {\n      if (Object.prototype.hasOwnProperty.call(pdfParams, prop)) {\n        string += `${encodeURIComponent(prop)}=${encodeURIComponent(\n          String(pdfParams[prop])\n        )}&`\n      }\n    }\n\n    // The string will be empty if no PDF Params found\n    if (string) {\n      string = `#${string}`\n\n      // Remove last ampersand\n      string = string.slice(0, string.length - 1)\n    }\n  }\n\n  return string\n}\n\nfunction embedError (msg: string): void {\n  console.log(`[pdfo] ${msg}`)\n}\n\nfunction emptyNodeContents (node: HTMLElement): void {\n  while (node.firstChild) {\n    node.removeChild(node.firstChild)\n  }\n}\n\nfunction generatePDFoMarkup (\n  embedType: string,\n  targetNode: HTMLElement,\n  url: string,\n  pdfOpenFragment: string,\n  width: string,\n  height: string,\n  omitInlineStyles: boolean\n): void {\n  // Ensure target element is empty first\n  emptyNodeContents(targetNode)\n\n  const embed = document.createElement('iframe')\n  embed.allow = 'fullscreen'\n\n  embed.src = embedType === 'fallback' ? url : url + pdfOpenFragment\n  embed.className = 'pdfo'\n\n  if (!omitInlineStyles) {\n    let style = 'border: none;'\n\n    if (targetNode === document.body) {\n      style +=\n        'position: absolute; top: 0; right: 0; bottom: 0; left: 0; width: 100%; height: 100%;'\n    } else {\n      style += `width: ${width}; height: ${height};`\n    }\n\n    embed.style.cssText = style\n  }\n\n  targetNode.classList.add('pdfo-container')\n\n  // This is where the magic finally happens\n  targetNode.appendChild(embed)\n}\n\nfunction getTargetElement (targetSelector: string): HTMLElement {\n  let targetNode: HTMLElement\n\n  if (targetSelector) {\n    targetNode = document.querySelector(targetSelector) || document.body\n  } else {\n    targetNode = document.body\n  }\n\n  return targetNode\n}\n", "import * as pdfo from './pdfo'\n\nconst pdfOptions = {\n  pdfOpenParams: {\n    view: 'Fit'\n  }\n}\n\npdfo.embed('dummy.pdf', '#pdf-box', pdfOptions)\n"],
  "mappings": "mBA+BA,IAAMA,EAAM,OAAO,UACbC,EAAK,OAAO,UAAU,UAhC5BC,EAmCMC,GAAgBD,EAAAF,EAAI,gBAAJ,YAAAE,EAAmB,OAInCE,EACJJ,EAAI,WAAa,QACjBA,EAAI,WAAa,YACjBA,EAAI,iBAAmB,QACvBA,EAAI,eAAiB,EAGjBK,EACJF,IAAkB,IAClB,kCAAkC,KAAKF,CAAE,GACzCG,EAMK,SAASE,EACdC,EACAC,EACAC,EACM,CAEN,IAAMC,EAAMD,GAAW,CAAC,EAGlBE,EAAgBD,EAAI,eAAiB,CAAC,EACtCE,EAAQF,EAAI,OAAS,OACrBG,EAASH,EAAI,QAAU,OACvBI,EACJ,OAAOJ,EAAI,eAAkB,UAAYA,EAAI,cAAgB,GACzDK,EACJ,OAAOL,EAAI,kBAAqB,UAAYA,EAAI,iBAAmB,GAG/DM,EACJ,OAAON,EAAI,cAAiB,SACxBA,EAAI,aACJ,0HACAO,EAAiBP,EAAI,gBAAkB,GAGvCQ,EAAaC,EADFX,GAAkB,EACS,EAI5C,GAAI,CAACU,EACH,OAAOE,EAAW,qCAAqC,EAIzD,IAAMC,EAAkBC,EAAuBX,CAAa,EAO5D,OAAIY,EAAa,GAAMT,GAAiB,CAACT,EAYhCmB,EAFW,SAIhBN,EACAX,EACAc,EACAT,EACAC,EACAE,CACF,EAKEE,EAGKO,EAFW,WAIhBN,EACAD,EAAiBV,EACjBc,EACAT,EACAC,EACAE,CACF,GAIEC,IACFE,EAAW,UAAYF,EAAa,QAAQ,UAAWT,CAAG,GAGrDa,EAAW,6CAA6C,EACjE,CAEO,SAASG,GAAyB,CAEvC,IAAME,EAAmBzB,EAAI,iBAG7B,OAAI,OAAOyB,GAAqB,UACvBA,EAckB,CAACpB,GAJJ,OAAO,SAAY,WAO7C,CAMA,SAASiB,EAAwBI,EAA4C,CAC3E,IAAIC,EAAS,GAEb,GAAID,EAAW,CACb,QAAWE,KAAQF,EACb,OAAO,UAAU,eAAe,KAAKA,EAAWE,CAAI,IACtDD,GAAU,GAAG,mBAAmBC,CAAI,KAAK,mBACvC,OAAOF,EAAUE,CAAI,CAAC,CACxB,MAKAD,IACFA,EAAS,IAAIA,IAGbA,EAASA,EAAO,MAAM,EAAGA,EAAO,OAAS,CAAC,GAI9C,OAAOA,CACT,CAEA,SAASP,EAAYS,EAAmB,CACtC,QAAQ,IAAI,UAAUA,GAAK,CAC7B,CAEA,SAASC,EAAmBC,EAAyB,CACnD,KAAOA,EAAK,YACVA,EAAK,YAAYA,EAAK,UAAU,CAEpC,CAEA,SAASP,EACPQ,EACAd,EACAX,EACAc,EACAT,EACAC,EACAE,EACM,CAENe,EAAkBZ,CAAU,EAE5B,IAAMZ,EAAQ,SAAS,cAAc,QAAQ,EAM7C,GALAA,EAAM,MAAQ,aAEdA,EAAM,IAAM0B,IAAc,WAAazB,EAAMA,EAAMc,EACnDf,EAAM,UAAY,OAEd,CAACS,EAAkB,CACrB,IAAIkB,EAAQ,gBAERf,IAAe,SAAS,KAC1Be,GACE,uFAEFA,GAAS,UAAUrB,cAAkBC,KAGvCP,EAAM,MAAM,QAAU2B,EAGxBf,EAAW,UAAU,IAAI,gBAAgB,EAGzCA,EAAW,YAAYZ,CAAK,CAC9B,CAEA,SAASa,EAAkBX,EAAqC,CAC9D,IAAIU,EAEJ,OAAIV,EACFU,EAAa,SAAS,cAAcV,CAAc,GAAK,SAAS,KAEhEU,EAAa,SAAS,KAGjBA,CACT,CC3PA,IAAMgB,EAAa,CACjB,cAAe,CACb,KAAM,KACR,CACF,EAEKC,EAAM,YAAa,WAAYD,CAAU",
  "names": ["nav", "ua", "_a", "newMobileTest", "isSafariIOSDesktopMode", "isMobileDevice", "embed", "url", "targetSelector", "options", "opt", "pdfOpenParams", "width", "height", "assumeSupport", "omitInlineStyles", "fallbackLink", "fallbackPrefix", "targetNode", "getTargetElement", "embedError", "pdfOpenFragment", "buildURLFragmentString", "supportsPDFs", "generatePDFoMarkup", "pdfViewerEnabled", "pdfParams", "string", "prop", "msg", "emptyNodeContents", "node", "embedType", "style", "pdfOptions", "embed"]
}
